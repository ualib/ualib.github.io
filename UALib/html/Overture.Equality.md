---
layout: default
title : Overture.Equality module (Agda Universal Algebra Library)
date : 2021-01-12
author: William DeMeo
---

### <a id="equality">Equality</a>

This is the [Overture.Equality][] module of the [Agda Universal Algebra Library][].

<pre class="Agda">

<a id="266" class="Symbol">{-#</a> <a id="270" class="Keyword">OPTIONS</a> <a id="278" class="Pragma">--without-K</a> <a id="290" class="Pragma">--exact-split</a> <a id="304" class="Pragma">--safe</a> <a id="311" class="Symbol">#-}</a>

<a id="316" class="Keyword">module</a> <a id="323" href="Overture.Equality.html" class="Module">Overture.Equality</a> <a id="341" class="Keyword">where</a>

<a id="348" class="Keyword">open</a> <a id="353" class="Keyword">import</a> <a id="360" href="Overture.Preliminaries.html" class="Module">Overture.Preliminaries</a> <a id="383" class="Keyword">public</a>

</pre>

#### <a id="definitional-equality">Definitional equality</a>

Here we discuss what is probably the most important type in [MLTT][]. It is called *definitional equality*. This concept is easily understood, at least heuristically, with the following slogan:

*Definitional equality is the substitution-preserving equivalence relation generated by definitions.*

We will make this precise below, but first let us quote from a primary source.

In [An Intuitionistic Theory of Types: Predicative Part](https://www.sciencedirect.com/science/article/pii/S0049237X08719451), Per Martin-Löf offers the following definition (italics added):<sup>[1](Overture.Equality.html#fn1)</sup>

"*Definitional equality* is defined to be the equivalence relation, that is, reflexive, symmetric and transitive relation, which is generated by the principles that a definiendum is always definitionally equal to its definiens and that definitional equality is preserved under substitution."<sup>[2](Overture.Equality.html#fn2)

To be sure we understand what this means, let `:=` denote the relation with respect to which `x` is related to `y` (denoted `x := y`) if and only if `y` *is the definition of* `x`.  Then the definitional equality relation `≡` is the reflexive, symmetric, transitive, substitutive closure of `:=`. By *subsitutive closure* we mean closure under the following *substitution rule*.


```agda
    {A : 𝓤 ̇} {B : A → 𝓦 ̇} {x y : A}   x ≡ y
    ------------------------------------------ (subst)
                B x ≡ B y
```

The datatype we use to represent definitional equality is imported from the Identity-Type module of the [Type Topology][] library, but apart from superficial syntactic differences, it is equivalent to the standard *Paulin-Mohring style identity type* found in most other Agda libraries.  We repeat the definition here for easy reference.

<pre class="Agda">

<a id="2280" class="Keyword">module</a> <a id="hide-refl"></a><a id="2287" href="Overture.Equality.html#2287" class="Module">hide-refl</a> <a id="2297" class="Keyword">where</a>

 <a id="2305" class="Keyword">data</a> <a id="hide-refl._≡_"></a><a id="2310" href="Overture.Equality.html#2310" class="Datatype Operator">_≡_</a> <a id="2314" class="Symbol">{</a><a id="2315" href="Overture.Equality.html#2315" class="Bound">A</a> <a id="2317" class="Symbol">:</a> <a id="2319" href="Universes.html#260" class="Generalizable">𝓤</a> <a id="2321" href="Universes.html#403" class="Function Operator">̇</a><a id="2322" class="Symbol">}</a> <a id="2324" class="Symbol">:</a> <a id="2326" href="Overture.Equality.html#2315" class="Bound">A</a> <a id="2328" class="Symbol">→</a> <a id="2330" href="Overture.Equality.html#2315" class="Bound">A</a> <a id="2332" class="Symbol">→</a> <a id="2334" href="Overture.Equality.html#2319" class="Bound">𝓤</a> <a id="2336" href="Universes.html#403" class="Function Operator">̇</a> <a id="2338" class="Keyword">where</a> <a id="hide-refl._≡_.refl"></a><a id="2344" href="Overture.Equality.html#2344" class="InductiveConstructor">refl</a> <a id="2349" class="Symbol">:</a> <a id="2351" class="Symbol">{</a><a id="2352" href="Overture.Equality.html#2352" class="Bound">x</a> <a id="2354" class="Symbol">:</a> <a id="2356" href="Overture.Equality.html#2315" class="Bound">A</a><a id="2357" class="Symbol">}</a> <a id="2359" class="Symbol">→</a> <a id="2361" href="Overture.Equality.html#2352" class="Bound">x</a> <a id="2363" href="Overture.Equality.html#2310" class="Datatype Operator">≡</a> <a id="2365" href="Overture.Equality.html#2352" class="Bound">x</a>

<a id="2368" class="Keyword">open</a> <a id="2373" class="Keyword">import</a> <a id="2380" href="Identity-Type.html" class="Module">Identity-Type</a> <a id="2394" class="Keyword">renaming</a> <a id="2403" class="Symbol">(</a><a id="2404" href="Identity-Type.html#121" class="Datatype Operator">_≡_</a> <a id="2408" class="Symbol">to</a> <a id="2411" class="Keyword">infix</a> <a id="2417" class="Number">0</a> <a id="2419" class="Datatype Operator">_≡_</a><a id="2422" class="Symbol">)</a> <a id="2424" class="Keyword">public</a>

</pre>

Whenever we need to complete a proof by simply asserting that `x` is definitionally equal to itself, we invoke `refl`.  If we need to make explicit the implicit argument `x`, then we use `refl {x = x}`.



#### <a id="identity-is-an-equivalence-relation">Identity is an equivalence relation</a>

The `≡` type just defined is an equivalence relation and the formal proof of this fact is trivial. We don't need to prove reflexivity since it is the defining property of `≡`.  Here are the (trivial) proofs of symmetry and transitivity of `≡`.

<pre class="Agda">

<a id="≡-sym"></a><a id="2999" href="Overture.Equality.html#2999" class="Function">≡-sym</a> <a id="3005" class="Symbol">:</a> <a id="3007" class="Symbol">{</a><a id="3008" href="Overture.Equality.html#3008" class="Bound">A</a> <a id="3010" class="Symbol">:</a> <a id="3012" href="Universes.html#260" class="Generalizable">𝓤</a> <a id="3014" href="Universes.html#403" class="Function Operator">̇</a><a id="3015" class="Symbol">}{</a><a id="3017" href="Overture.Equality.html#3017" class="Bound">x</a> <a id="3019" href="Overture.Equality.html#3019" class="Bound">y</a> <a id="3021" class="Symbol">:</a> <a id="3023" href="Overture.Equality.html#3008" class="Bound">A</a><a id="3024" class="Symbol">}</a> <a id="3026" class="Symbol">→</a> <a id="3028" href="Overture.Equality.html#3017" class="Bound">x</a> <a id="3030" href="Overture.Equality.html#2419" class="Datatype Operator">≡</a> <a id="3032" href="Overture.Equality.html#3019" class="Bound">y</a> <a id="3034" class="Symbol">→</a> <a id="3036" href="Overture.Equality.html#3019" class="Bound">y</a> <a id="3038" href="Overture.Equality.html#2419" class="Datatype Operator">≡</a> <a id="3040" href="Overture.Equality.html#3017" class="Bound">x</a>
<a id="3042" href="Overture.Equality.html#2999" class="Function">≡-sym</a> <a id="3048" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="3053" class="Symbol">=</a> <a id="3055" href="Identity-Type.html#162" class="InductiveConstructor">refl</a>

<a id="≡-trans"></a><a id="3061" href="Overture.Equality.html#3061" class="Function">≡-trans</a> <a id="3069" class="Symbol">:</a> <a id="3071" class="Symbol">{</a><a id="3072" href="Overture.Equality.html#3072" class="Bound">A</a> <a id="3074" class="Symbol">:</a> <a id="3076" href="Universes.html#260" class="Generalizable">𝓤</a> <a id="3078" href="Universes.html#403" class="Function Operator">̇</a><a id="3079" class="Symbol">}{</a><a id="3081" href="Overture.Equality.html#3081" class="Bound">x</a> <a id="3083" href="Overture.Equality.html#3083" class="Bound">y</a> <a id="3085" href="Overture.Equality.html#3085" class="Bound">z</a> <a id="3087" class="Symbol">:</a> <a id="3089" href="Overture.Equality.html#3072" class="Bound">A</a><a id="3090" class="Symbol">}</a> <a id="3092" class="Symbol">→</a> <a id="3094" href="Overture.Equality.html#3081" class="Bound">x</a> <a id="3096" href="Overture.Equality.html#2419" class="Datatype Operator">≡</a> <a id="3098" href="Overture.Equality.html#3083" class="Bound">y</a> <a id="3100" class="Symbol">→</a> <a id="3102" href="Overture.Equality.html#3083" class="Bound">y</a> <a id="3104" href="Overture.Equality.html#2419" class="Datatype Operator">≡</a> <a id="3106" href="Overture.Equality.html#3085" class="Bound">z</a> <a id="3108" class="Symbol">→</a> <a id="3110" href="Overture.Equality.html#3081" class="Bound">x</a> <a id="3112" href="Overture.Equality.html#2419" class="Datatype Operator">≡</a> <a id="3114" href="Overture.Equality.html#3085" class="Bound">z</a>
<a id="3116" href="Overture.Equality.html#3061" class="Function">≡-trans</a> <a id="3124" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="3129" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="3134" class="Symbol">=</a> <a id="3136" href="Identity-Type.html#162" class="InductiveConstructor">refl</a>

</pre>

We prove that `≡` obeys the substitution rule (subst) in the next subsection (see the definition of `ap` below), but first we define some syntactic sugar that will make it easier to apply symmetry and transitivity of `≡` in proofs.<sup>[3](Overture.Equality.html#fn3)</sup>

<pre class="Agda">

<a id="3443" class="Keyword">module</a> <a id="hide-sym-trans"></a><a id="3450" href="Overture.Equality.html#3450" class="Module">hide-sym-trans</a> <a id="3465" class="Symbol">{</a><a id="3466" href="Overture.Equality.html#3466" class="Bound">A</a> <a id="3468" class="Symbol">:</a> <a id="3470" href="Universes.html#260" class="Generalizable">𝓤</a> <a id="3472" href="Universes.html#403" class="Function Operator">̇</a><a id="3473" class="Symbol">}</a> <a id="3475" class="Keyword">where</a>

 <a id="hide-sym-trans._⁻¹"></a><a id="3483" href="Overture.Equality.html#3483" class="Function Operator">_⁻¹</a> <a id="3487" class="Symbol">:</a> <a id="3489" class="Symbol">{</a><a id="3490" href="Overture.Equality.html#3490" class="Bound">x</a> <a id="3492" href="Overture.Equality.html#3492" class="Bound">y</a> <a id="3494" class="Symbol">:</a> <a id="3496" href="Overture.Equality.html#3466" class="Bound">A</a><a id="3497" class="Symbol">}</a> <a id="3499" class="Symbol">→</a> <a id="3501" href="Overture.Equality.html#3490" class="Bound">x</a> <a id="3503" href="Overture.Equality.html#2419" class="Datatype Operator">≡</a> <a id="3505" href="Overture.Equality.html#3492" class="Bound">y</a> <a id="3507" class="Symbol">→</a> <a id="3509" href="Overture.Equality.html#3492" class="Bound">y</a> <a id="3511" href="Overture.Equality.html#2419" class="Datatype Operator">≡</a> <a id="3513" href="Overture.Equality.html#3490" class="Bound">x</a>
 <a id="3516" href="Overture.Equality.html#3516" class="Bound">p</a> <a id="3518" href="Overture.Equality.html#3483" class="Function Operator">⁻¹</a> <a id="3521" class="Symbol">=</a> <a id="3523" href="Overture.Equality.html#2999" class="Function">≡-sym</a> <a id="3529" href="Overture.Equality.html#3516" class="Bound">p</a>

</pre>

If we have a proof `p : x ≡ y`, and we need a proof of `y ≡ x`, then instead of `≡-sym p` we can use the more intuitive `p ⁻¹` . Similarly, the following syntactic sugar makes abundant appeals to transitivity easier to stomach.

<pre class="Agda">

 <a id="hide-sym-trans._∙_"></a><a id="3788" href="Overture.Equality.html#3788" class="Function Operator">_∙_</a> <a id="3792" class="Symbol">:</a> <a id="3794" class="Symbol">{</a><a id="3795" href="Overture.Equality.html#3795" class="Bound">x</a> <a id="3797" href="Overture.Equality.html#3797" class="Bound">y</a> <a id="3799" href="Overture.Equality.html#3799" class="Bound">z</a> <a id="3801" class="Symbol">:</a> <a id="3803" href="Overture.Equality.html#3466" class="Bound">A</a><a id="3804" class="Symbol">}</a> <a id="3806" class="Symbol">→</a> <a id="3808" href="Overture.Equality.html#3795" class="Bound">x</a> <a id="3810" href="Overture.Equality.html#2419" class="Datatype Operator">≡</a> <a id="3812" href="Overture.Equality.html#3797" class="Bound">y</a> <a id="3814" class="Symbol">→</a> <a id="3816" href="Overture.Equality.html#3797" class="Bound">y</a> <a id="3818" href="Overture.Equality.html#2419" class="Datatype Operator">≡</a> <a id="3820" href="Overture.Equality.html#3799" class="Bound">z</a> <a id="3822" class="Symbol">→</a> <a id="3824" href="Overture.Equality.html#3795" class="Bound">x</a> <a id="3826" href="Overture.Equality.html#2419" class="Datatype Operator">≡</a> <a id="3828" href="Overture.Equality.html#3799" class="Bound">z</a>
 <a id="3831" href="Overture.Equality.html#3831" class="Bound">p</a> <a id="3833" href="Overture.Equality.html#3788" class="Function Operator">∙</a> <a id="3835" href="Overture.Equality.html#3835" class="Bound">q</a> <a id="3837" class="Symbol">=</a> <a id="3839" href="Overture.Equality.html#3061" class="Function">≡-trans</a> <a id="3847" href="Overture.Equality.html#3831" class="Bound">p</a> <a id="3849" href="Overture.Equality.html#3835" class="Bound">q</a>

</pre>

As usual, we import the original definitions from the [Type Topology][] library.

<pre class="Agda">

<a id="3960" class="Keyword">open</a> <a id="3965" class="Keyword">import</a> <a id="3972" href="MGS-MLTT.html" class="Module">MGS-MLTT</a> <a id="3981" class="Keyword">using</a> <a id="3987" class="Symbol">(</a><a id="3988" href="MGS-MLTT.html#6125" class="Function Operator">_⁻¹</a><a id="3991" class="Symbol">;</a> <a id="3993" href="MGS-MLTT.html#5910" class="Function Operator">_∙_</a><a id="3996" class="Symbol">)</a> <a id="3998" class="Keyword">public</a>

</pre>

#### <a id="transport">Transport (substitution)</a>

Alonzo Church characterized equality by declaring two things equal iff no property (predicate) can distinguish them.<sup>[4](Overture.Equality.html#fn4)</sup>  In other terms, `x` and `y` are equal iff for all `P` we have `P x → P y`.  One direction of this implication is sometimes called *substitution* or *transport* or *transport along an identity*.  It asserts that *if* two objects are equal and one of them satisfies a predicate, then so does the other. A type representing this notion is defined in the `MGS-MLTT` module of the [Type Topology][] library as follows.<sup>[3](Preliminaries.Equality.html#fn3)</sup>

<pre class="Agda">

<a id="4707" class="Keyword">module</a> <a id="hide-id-transport"></a><a id="4714" href="Overture.Equality.html#4714" class="Module">hide-id-transport</a> <a id="4732" class="Keyword">where</a>

 <a id="hide-id-transport.𝑖𝑑"></a><a id="4740" href="Overture.Equality.html#4740" class="Function">𝑖𝑑</a> <a id="4743" class="Symbol">:</a> <a id="4745" class="Symbol">(</a><a id="4746" href="Overture.Equality.html#4746" class="Bound">A</a> <a id="4748" class="Symbol">:</a> <a id="4750" href="Universes.html#260" class="Generalizable">𝓤</a> <a id="4752" href="Universes.html#403" class="Function Operator">̇</a> <a id="4754" class="Symbol">)</a> <a id="4756" class="Symbol">→</a> <a id="4758" href="Overture.Equality.html#4746" class="Bound">A</a> <a id="4760" class="Symbol">→</a> <a id="4762" href="Overture.Equality.html#4746" class="Bound">A</a>
 <a id="4765" href="Overture.Equality.html#4740" class="Function">𝑖𝑑</a> <a id="4768" href="Overture.Equality.html#4768" class="Bound">A</a> <a id="4770" class="Symbol">=</a> <a id="4772" class="Symbol">λ</a> <a id="4774" href="Overture.Equality.html#4774" class="Bound">x</a> <a id="4776" class="Symbol">→</a> <a id="4778" href="Overture.Equality.html#4774" class="Bound">x</a>

 <a id="hide-id-transport.transport"></a><a id="4782" href="Overture.Equality.html#4782" class="Function">transport</a> <a id="4792" class="Symbol">:</a> <a id="4794" class="Symbol">{</a><a id="4795" href="Overture.Equality.html#4795" class="Bound">A</a> <a id="4797" class="Symbol">:</a> <a id="4799" href="Universes.html#260" class="Generalizable">𝓤</a> <a id="4801" href="Universes.html#403" class="Function Operator">̇</a><a id="4802" class="Symbol">}(</a><a id="4804" href="Overture.Equality.html#4804" class="Bound">B</a> <a id="4806" class="Symbol">:</a> <a id="4808" href="Overture.Equality.html#4795" class="Bound">A</a> <a id="4810" class="Symbol">→</a> <a id="4812" href="Universes.html#264" class="Generalizable">𝓦</a> <a id="4814" href="Universes.html#403" class="Function Operator">̇</a><a id="4815" class="Symbol">){</a><a id="4817" href="Overture.Equality.html#4817" class="Bound">x</a> <a id="4819" href="Overture.Equality.html#4819" class="Bound">y</a> <a id="4821" class="Symbol">:</a> <a id="4823" href="Overture.Equality.html#4795" class="Bound">A</a><a id="4824" class="Symbol">}</a> <a id="4826" class="Symbol">→</a> <a id="4828" href="Overture.Equality.html#4817" class="Bound">x</a> <a id="4830" href="Overture.Equality.html#2419" class="Datatype Operator">≡</a> <a id="4832" href="Overture.Equality.html#4819" class="Bound">y</a> <a id="4834" class="Symbol">→</a> <a id="4836" href="Overture.Equality.html#4804" class="Bound">B</a> <a id="4838" href="Overture.Equality.html#4817" class="Bound">x</a> <a id="4840" class="Symbol">→</a> <a id="4842" href="Overture.Equality.html#4804" class="Bound">B</a> <a id="4844" href="Overture.Equality.html#4819" class="Bound">y</a>
 <a id="4847" href="Overture.Equality.html#4782" class="Function">transport</a> <a id="4857" href="Overture.Equality.html#4857" class="Bound">B</a> <a id="4859" class="Symbol">(</a><a id="4860" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="4865" class="Symbol">{</a><a id="4866" class="Argument">x</a> <a id="4868" class="Symbol">=</a> <a id="4870" href="Overture.Equality.html#4870" class="Bound">x</a><a id="4871" class="Symbol">})</a> <a id="4874" class="Symbol">=</a> <a id="4876" href="Overture.Equality.html#4740" class="Function">𝑖𝑑</a> <a id="4879" class="Symbol">(</a><a id="4880" href="Overture.Equality.html#4857" class="Bound">B</a> <a id="4882" href="Overture.Equality.html#4870" class="Bound">x</a><a id="4883" class="Symbol">)</a>

<a id="4886" class="Keyword">open</a> <a id="4891" class="Keyword">import</a> <a id="4898" href="MGS-MLTT.html" class="Module">MGS-MLTT</a> <a id="4907" class="Keyword">using</a> <a id="4913" class="Symbol">(</a><a id="4914" href="MGS-MLTT.html#3778" class="Function">𝑖𝑑</a><a id="4916" class="Symbol">;</a> <a id="4918" href="MGS-MLTT.html#4946" class="Function">transport</a><a id="4927" class="Symbol">)</a> <a id="4929" class="Keyword">public</a>

</pre>

As usual, we display definitions of existing types (here, `𝑖𝑑` and `transport`) in a hidden module and then imported their original definition from [Type Topology][].

A function is well defined if and only if it maps equivalent elements to a single element and we often use this nature of functions in Agda proofs.  If we have a function `f : X → Y`, two elements `a b : X` of the domain, and an identity proof `p : a ≡ b`, then we obtain a proof of `f a ≡ f b` by simply applying the `ap` function like so, `ap f p : f a ≡ f b`. Escardó defines `ap` in the [Type Topology][] library as follows.

<pre class="Agda">

<a id="5561" class="Keyword">module</a> <a id="hide-ap"></a><a id="5568" href="Overture.Equality.html#5568" class="Module">hide-ap</a> <a id="5576" class="Symbol">{</a><a id="5577" href="Overture.Equality.html#5577" class="Bound">A</a> <a id="5579" class="Symbol">:</a> <a id="5581" href="Universes.html#260" class="Generalizable">𝓤</a> <a id="5583" href="Universes.html#403" class="Function Operator">̇</a><a id="5584" class="Symbol">}{</a><a id="5586" href="Overture.Equality.html#5586" class="Bound">B</a> <a id="5588" class="Symbol">:</a> <a id="5590" href="Universes.html#264" class="Generalizable">𝓦</a> <a id="5592" href="Universes.html#403" class="Function Operator">̇</a><a id="5593" class="Symbol">}</a> <a id="5595" class="Keyword">where</a>

 <a id="hide-ap.ap"></a><a id="5603" href="Overture.Equality.html#5603" class="Function">ap</a> <a id="5606" class="Symbol">:</a> <a id="5608" class="Symbol">(</a><a id="5609" href="Overture.Equality.html#5609" class="Bound">f</a> <a id="5611" class="Symbol">:</a> <a id="5613" href="Overture.Equality.html#5577" class="Bound">A</a> <a id="5615" class="Symbol">→</a> <a id="5617" href="Overture.Equality.html#5586" class="Bound">B</a><a id="5618" class="Symbol">){</a><a id="5620" href="Overture.Equality.html#5620" class="Bound">x</a> <a id="5622" href="Overture.Equality.html#5622" class="Bound">y</a> <a id="5624" class="Symbol">:</a> <a id="5626" href="Overture.Equality.html#5577" class="Bound">A</a><a id="5627" class="Symbol">}</a> <a id="5629" class="Symbol">→</a> <a id="5631" href="Overture.Equality.html#5620" class="Bound">x</a> <a id="5633" href="Overture.Equality.html#2419" class="Datatype Operator">≡</a> <a id="5635" href="Overture.Equality.html#5622" class="Bound">y</a> <a id="5637" class="Symbol">→</a> <a id="5639" href="Overture.Equality.html#5609" class="Bound">f</a> <a id="5641" href="Overture.Equality.html#5620" class="Bound">x</a> <a id="5643" href="Overture.Equality.html#2419" class="Datatype Operator">≡</a> <a id="5645" href="Overture.Equality.html#5609" class="Bound">f</a> <a id="5647" href="Overture.Equality.html#5622" class="Bound">y</a>
 <a id="5650" href="Overture.Equality.html#5603" class="Function">ap</a> <a id="5653" href="Overture.Equality.html#5653" class="Bound">f</a> <a id="5655" class="Symbol">{</a><a id="5656" href="Overture.Equality.html#5656" class="Bound">x</a><a id="5657" class="Symbol">}</a> <a id="5659" href="Overture.Equality.html#5659" class="Bound">p</a> <a id="5661" class="Symbol">=</a> <a id="5663" href="MGS-MLTT.html#4946" class="Function">transport</a> <a id="5673" class="Symbol">(λ</a> <a id="5676" href="Overture.Equality.html#5676" class="Bound">-</a> <a id="5678" class="Symbol">→</a> <a id="5680" href="Overture.Equality.html#5653" class="Bound">f</a> <a id="5682" href="Overture.Equality.html#5656" class="Bound">x</a> <a id="5684" href="Overture.Equality.html#2419" class="Datatype Operator">≡</a> <a id="5686" href="Overture.Equality.html#5653" class="Bound">f</a> <a id="5688" href="Overture.Equality.html#5676" class="Bound">-</a><a id="5689" class="Symbol">)</a> <a id="5691" href="Overture.Equality.html#5659" class="Bound">p</a> <a id="5693" class="Symbol">(</a><a id="5694" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="5699" class="Symbol">{</a><a id="5700" class="Argument">x</a> <a id="5702" class="Symbol">=</a> <a id="5704" href="Overture.Equality.html#5653" class="Bound">f</a> <a id="5706" href="Overture.Equality.html#5656" class="Bound">x</a><a id="5707" class="Symbol">})</a>

<a id="5711" class="Keyword">open</a> <a id="5716" class="Keyword">import</a> <a id="5723" href="MGS-MLTT.html" class="Module">MGS-MLTT</a> <a id="5732" class="Keyword">using</a> <a id="5738" class="Symbol">(</a><a id="5739" href="MGS-MLTT.html#6613" class="Function">ap</a><a id="5741" class="Symbol">)</a> <a id="5743" class="Keyword">public</a>

</pre>

Here's a useful variation of `ap` that we borrow from the `Relation/Binary/Core.agda` module of the [Agda Standard Library][] (transcribed into TypeTopology/UALib notation of course).

<pre class="Agda">

<a id="cong-app"></a><a id="5962" href="Overture.Equality.html#5962" class="Function">cong-app</a> <a id="5971" class="Symbol">:</a> <a id="5973" class="Symbol">{</a><a id="5974" href="Overture.Equality.html#5974" class="Bound">A</a> <a id="5976" class="Symbol">:</a> <a id="5978" href="Universes.html#260" class="Generalizable">𝓤</a> <a id="5980" href="Universes.html#403" class="Function Operator">̇</a><a id="5981" class="Symbol">}{</a><a id="5983" href="Overture.Equality.html#5983" class="Bound">B</a> <a id="5985" class="Symbol">:</a> <a id="5987" href="Overture.Equality.html#5974" class="Bound">A</a> <a id="5989" class="Symbol">→</a> <a id="5991" href="Universes.html#264" class="Generalizable">𝓦</a> <a id="5993" href="Universes.html#403" class="Function Operator">̇</a><a id="5994" class="Symbol">}{</a><a id="5996" href="Overture.Equality.html#5996" class="Bound">f</a> <a id="5998" href="Overture.Equality.html#5998" class="Bound">g</a> <a id="6000" class="Symbol">:</a> <a id="6002" href="MGS-MLTT.html#3562" class="Function">Π</a> <a id="6004" href="Overture.Equality.html#5983" class="Bound">B</a><a id="6005" class="Symbol">}</a> <a id="6007" class="Symbol">→</a> <a id="6009" href="Overture.Equality.html#5996" class="Bound">f</a> <a id="6011" href="Overture.Equality.html#2419" class="Datatype Operator">≡</a> <a id="6013" href="Overture.Equality.html#5998" class="Bound">g</a> <a id="6015" class="Symbol">→</a> <a id="6017" class="Symbol">∀</a> <a id="6019" href="Overture.Equality.html#6019" class="Bound">x</a> <a id="6021" class="Symbol">→</a> <a id="6023" href="Overture.Equality.html#5996" class="Bound">f</a> <a id="6025" href="Overture.Equality.html#6019" class="Bound">x</a> <a id="6027" href="Overture.Equality.html#2419" class="Datatype Operator">≡</a> <a id="6029" href="Overture.Equality.html#5998" class="Bound">g</a> <a id="6031" href="Overture.Equality.html#6019" class="Bound">x</a>
<a id="6033" href="Overture.Equality.html#5962" class="Function">cong-app</a> <a id="6042" href="Identity-Type.html#162" class="InductiveConstructor">refl</a> <a id="6047" class="Symbol">_</a> <a id="6049" class="Symbol">=</a> <a id="6051" href="Identity-Type.html#162" class="InductiveConstructor">refl</a>

</pre>





-------------------------------------


<sup>1</sup><span class="footnote" id="fn1"> Per Martin-Löf, *An intuitionistic theory of types: predicative part*, Logic Colloquium '73 (Bristol, 1973), 73--118, Studies in Logic and the Foundations of Mathematics, Vol. 80, 1975.</span>

<sup>2</sup><span class="footnote" id="fn2"> The *definiendum* is the left-hand side of a defining equation, the *definiens* is the right-hand side. For readers who have never generated an equivalence relation: the *reflexive closure* of `R ⊆ A × A `is the union of `R` and all pairs of the form `(a , a)`; the *symmetric closure* is the union of `R` and its inverse `{(y , x) : (x , y) ∈ R}`; we leave it to the reader to come up with the correct definition of transitive closure.</span>

<sup>3</sup><span class="footnote" id="fn3"> **Unicode Hints** ([agda2-mode][]). `\^-\^1 ↝ ⁻¹`; `\Mii\Mid ↝ 𝑖𝑑`; `\. ↝ ∙`. In general, for information about a character, place the cursor over that character and type `M-x describe-char` (or `M-x h d c`).</span>



<sup>4</sup><span class="footnote" id="fn4"> Alonzo Church, "A Formulation of the Simple Theory of Types," *Journal of Symbolic Logic*, (2)5:56--68, 1940 [JSOR link](http://www.jstor.org/stable/2266170). See also [this section](https://www.cs.bham.ac.uk/~mhe/HoTT-UF-in-Agda-Lecture-Notes/HoTT-UF-Agda.html#70309) of Escardó's [HoTT/UF in Agda notes](https://www.cs.bham.ac.uk/~mhe/HoTT-UF-in-Agda-Lecture-Notes/HoTT-UF-Agda.html) for a discussion of transport; cf. [HoTT-Agda's definition](https://github.com/HoTT/HoTT-Agda/blob/master/core/lib/Base.agda).</span>

<br>
<br>

[← Overture.Preliminaries ](Overture.Preliminaries.html)
<span style="float:right;">[Overture.FunExtensionality →](Overture.FunExtensionality.html)</span>

{% include UALib.Links.md %}


