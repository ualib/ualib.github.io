---
layout: default
title : Overture.Inverses module (Agda Universal Algebra Library)
date : 2021-01-12
author: William DeMeo
---

### <a id="inverses">Inverses</a>

This is the [Overture.Inverses][] module of the [Agda Universal Algebra Library][].

<pre class="Agda">

<a id="266" class="Symbol">{-#</a> <a id="270" class="Keyword">OPTIONS</a> <a id="278" class="Pragma">--without-K</a> <a id="290" class="Pragma">--exact-split</a> <a id="304" class="Pragma">--safe</a> <a id="311" class="Symbol">#-}</a>

<a id="316" class="Keyword">module</a> <a id="323" href="Overture.Inverses.html" class="Module">Overture.Inverses</a> <a id="341" class="Keyword">where</a>

<a id="348" class="Keyword">open</a> <a id="353" class="Keyword">import</a> <a id="360" href="Overture.FunExtensionality.html" class="Module">Overture.FunExtensionality</a> <a id="387" class="Keyword">public</a>

<a id="395" class="Keyword">open</a> <a id="400" class="Keyword">import</a> <a id="407" href="MGS-Embeddings.html" class="Module">MGS-Embeddings</a>
 <a id="423" class="Keyword">using</a> <a id="429" class="Symbol">(</a><a id="430" href="MGS-Embeddings.html#1410" class="Function">equivs-are-embeddings</a><a id="451" class="Symbol">;</a> <a id="453" href="MGS-Equivalences.html#370" class="Function">invertible</a><a id="463" class="Symbol">;</a> <a id="465" href="MGS-Equivalences.html#2127" class="Function">invertibles-are-equivs</a><a id="487" class="Symbol">)</a> <a id="489" class="Keyword">public</a>

</pre>

We begin by defining an inductive type that represents the semantic concept of *inverse image* of a function.

<pre class="Agda">

<a id="634" class="Keyword">module</a> <a id="641" href="Overture.Inverses.html#641" class="Module">_</a> <a id="643" class="Symbol">{</a><a id="644" href="Overture.Inverses.html#644" class="Bound">A</a> <a id="646" class="Symbol">:</a> <a id="648" href="Universes.html#260" class="Generalizable">𝓤</a> <a id="650" href="Universes.html#403" class="Function Operator">̇</a> <a id="652" class="Symbol">}{</a><a id="654" href="Overture.Inverses.html#654" class="Bound">B</a> <a id="656" class="Symbol">:</a> <a id="658" href="Universes.html#264" class="Generalizable">𝓦</a> <a id="660" href="Universes.html#403" class="Function Operator">̇</a> <a id="662" class="Symbol">}</a> <a id="664" class="Keyword">where</a>

 <a id="672" class="Keyword">data</a> <a id="677" href="Overture.Inverses.html#677" class="Datatype Operator">Image_∋_</a> <a id="686" class="Symbol">(</a><a id="687" href="Overture.Inverses.html#687" class="Bound">f</a> <a id="689" class="Symbol">:</a> <a id="691" href="Overture.Inverses.html#644" class="Bound">A</a> <a id="693" class="Symbol">→</a> <a id="695" href="Overture.Inverses.html#654" class="Bound">B</a><a id="696" class="Symbol">)</a> <a id="698" class="Symbol">:</a> <a id="700" href="Overture.Inverses.html#654" class="Bound">B</a> <a id="702" class="Symbol">→</a> <a id="704" href="Overture.Inverses.html#648" class="Bound">𝓤</a> <a id="706" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a id="708" href="Overture.Inverses.html#658" class="Bound">𝓦</a> <a id="710" href="Universes.html#403" class="Function Operator">̇</a>
  <a id="714" class="Keyword">where</a>
  <a id="722" href="Overture.Inverses.html#722" class="InductiveConstructor">im</a> <a id="725" class="Symbol">:</a> <a id="727" class="Symbol">(</a><a id="728" href="Overture.Inverses.html#728" class="Bound">x</a> <a id="730" class="Symbol">:</a> <a id="732" href="Overture.Inverses.html#644" class="Bound">A</a><a id="733" class="Symbol">)</a> <a id="735" class="Symbol">→</a> <a id="737" href="Overture.Inverses.html#677" class="Datatype Operator">Image</a> <a id="743" href="Overture.Inverses.html#687" class="Bound">f</a> <a id="745" href="Overture.Inverses.html#677" class="Datatype Operator">∋</a> <a id="747" href="Overture.Inverses.html#687" class="Bound">f</a> <a id="749" href="Overture.Inverses.html#728" class="Bound">x</a>
  <a id="753" href="Overture.Inverses.html#753" class="InductiveConstructor">eq</a> <a id="756" class="Symbol">:</a> <a id="758" class="Symbol">(</a><a id="759" href="Overture.Inverses.html#759" class="Bound">b</a> <a id="761" class="Symbol">:</a> <a id="763" href="Overture.Inverses.html#654" class="Bound">B</a><a id="764" class="Symbol">)</a> <a id="766" class="Symbol">→</a> <a id="768" class="Symbol">(</a><a id="769" href="Overture.Inverses.html#769" class="Bound">a</a> <a id="771" class="Symbol">:</a> <a id="773" href="Overture.Inverses.html#644" class="Bound">A</a><a id="774" class="Symbol">)</a> <a id="776" class="Symbol">→</a> <a id="778" href="Overture.Inverses.html#759" class="Bound">b</a> <a id="780" href="Overture.Equality.html#2419" class="Datatype Operator">≡</a> <a id="782" href="Overture.Inverses.html#687" class="Bound">f</a> <a id="784" href="Overture.Inverses.html#769" class="Bound">a</a> <a id="786" class="Symbol">→</a> <a id="788" href="Overture.Inverses.html#677" class="Datatype Operator">Image</a> <a id="794" href="Overture.Inverses.html#687" class="Bound">f</a> <a id="796" href="Overture.Inverses.html#677" class="Datatype Operator">∋</a> <a id="798" href="Overture.Inverses.html#759" class="Bound">b</a>

</pre>

Next we verify that the type behaves as we expect.

<pre class="Agda">

 <a id="880" href="Overture.Inverses.html#880" class="Function">ImageIsImage</a> <a id="893" class="Symbol">:</a> <a id="895" class="Symbol">(</a><a id="896" href="Overture.Inverses.html#896" class="Bound">f</a> <a id="898" class="Symbol">:</a> <a id="900" href="Overture.Inverses.html#644" class="Bound">A</a> <a id="902" class="Symbol">→</a> <a id="904" href="Overture.Inverses.html#654" class="Bound">B</a><a id="905" class="Symbol">)(</a><a id="907" href="Overture.Inverses.html#907" class="Bound">b</a> <a id="909" class="Symbol">:</a> <a id="911" href="Overture.Inverses.html#654" class="Bound">B</a><a id="912" class="Symbol">)(</a><a id="914" href="Overture.Inverses.html#914" class="Bound">a</a> <a id="916" class="Symbol">:</a> <a id="918" href="Overture.Inverses.html#644" class="Bound">A</a><a id="919" class="Symbol">)</a> <a id="921" class="Symbol">→</a> <a id="923" href="Overture.Inverses.html#907" class="Bound">b</a> <a id="925" href="Overture.Equality.html#2419" class="Datatype Operator">≡</a> <a id="927" href="Overture.Inverses.html#896" class="Bound">f</a> <a id="929" href="Overture.Inverses.html#914" class="Bound">a</a> <a id="931" class="Symbol">→</a> <a id="933" href="Overture.Inverses.html#677" class="Datatype Operator">Image</a> <a id="939" href="Overture.Inverses.html#896" class="Bound">f</a> <a id="941" href="Overture.Inverses.html#677" class="Datatype Operator">∋</a> <a id="943" href="Overture.Inverses.html#907" class="Bound">b</a>
 <a id="946" href="Overture.Inverses.html#880" class="Function">ImageIsImage</a> <a id="959" href="Overture.Inverses.html#959" class="Bound">f</a> <a id="961" href="Overture.Inverses.html#961" class="Bound">b</a> <a id="963" href="Overture.Inverses.html#963" class="Bound">a</a> <a id="965" href="Overture.Inverses.html#965" class="Bound">b≡fa</a> <a id="970" class="Symbol">=</a> <a id="972" href="Overture.Inverses.html#753" class="InductiveConstructor">eq</a> <a id="975" href="Overture.Inverses.html#961" class="Bound">b</a> <a id="977" href="Overture.Inverses.html#963" class="Bound">a</a> <a id="979" href="Overture.Inverses.html#965" class="Bound">b≡fa</a>

</pre>

An inhabitant of `Image f ∋ b` is a dependent pair `(a , p)`, where `a : A` and `p : b ≡ f a` is a proof that `f` maps `a` to `b`.  Since the proof that `b` belongs to the image of `f` is always accompanied by a witness `a : A`, we can actually *compute* a (pseudo)inverse of `f`. For convenience, we define this inverse function, which we call `Inv`, and which takes an arbitrary `b : B` and a (*witness*, *proof*)-pair, `(a , p) : Image f ∋ b`, and returns the witness `a`.

<pre class="Agda">

 <a id="1489" href="Overture.Inverses.html#1489" class="Function">Inv</a> <a id="1493" class="Symbol">:</a> <a id="1495" class="Symbol">(</a><a id="1496" href="Overture.Inverses.html#1496" class="Bound">f</a> <a id="1498" class="Symbol">:</a> <a id="1500" href="Overture.Inverses.html#644" class="Bound">A</a> <a id="1502" class="Symbol">→</a> <a id="1504" href="Overture.Inverses.html#654" class="Bound">B</a><a id="1505" class="Symbol">){</a><a id="1507" href="Overture.Inverses.html#1507" class="Bound">b</a> <a id="1509" class="Symbol">:</a> <a id="1511" href="Overture.Inverses.html#654" class="Bound">B</a><a id="1512" class="Symbol">}</a> <a id="1514" class="Symbol">→</a> <a id="1516" href="Overture.Inverses.html#677" class="Datatype Operator">Image</a> <a id="1522" href="Overture.Inverses.html#1496" class="Bound">f</a> <a id="1524" href="Overture.Inverses.html#677" class="Datatype Operator">∋</a> <a id="1526" href="Overture.Inverses.html#1507" class="Bound">b</a>  <a id="1529" class="Symbol">→</a>  <a id="1532" href="Overture.Inverses.html#644" class="Bound">A</a>
 <a id="1535" href="Overture.Inverses.html#1489" class="Function">Inv</a> <a id="1539" href="Overture.Inverses.html#1539" class="Bound">f</a> <a id="1541" class="Symbol">{</a><a id="1542" class="DottedPattern Symbol">.(</a><a id="1544" href="Overture.Inverses.html#1539" class="DottedPattern Bound">f</a> <a id="1546" href="Overture.Inverses.html#1554" class="DottedPattern Bound">a</a><a id="1547" class="DottedPattern Symbol">)</a><a id="1548" class="Symbol">}</a> <a id="1550" class="Symbol">(</a><a id="1551" href="Overture.Inverses.html#722" class="InductiveConstructor">im</a> <a id="1554" href="Overture.Inverses.html#1554" class="Bound">a</a><a id="1555" class="Symbol">)</a> <a id="1557" class="Symbol">=</a> <a id="1559" href="Overture.Inverses.html#1554" class="Bound">a</a>
 <a id="1562" href="Overture.Inverses.html#1489" class="Function">Inv</a> <a id="1566" href="Overture.Inverses.html#1566" class="Bound">f</a> <a id="1568" class="Symbol">(</a><a id="1569" href="Overture.Inverses.html#753" class="InductiveConstructor">eq</a> <a id="1572" class="Symbol">_</a> <a id="1574" href="Overture.Inverses.html#1574" class="Bound">a</a> <a id="1576" class="Symbol">_)</a> <a id="1579" class="Symbol">=</a> <a id="1581" href="Overture.Inverses.html#1574" class="Bound">a</a>

</pre>

We can prove that `Inv f` is the *right-inverse* of `f`, as follows.

<pre class="Agda">

 <a id="1681" href="Overture.Inverses.html#1681" class="Function">InvIsInv</a> <a id="1690" class="Symbol">:</a> <a id="1692" class="Symbol">(</a><a id="1693" href="Overture.Inverses.html#1693" class="Bound">f</a> <a id="1695" class="Symbol">:</a> <a id="1697" href="Overture.Inverses.html#644" class="Bound">A</a> <a id="1699" class="Symbol">→</a> <a id="1701" href="Overture.Inverses.html#654" class="Bound">B</a><a id="1702" class="Symbol">){</a><a id="1704" href="Overture.Inverses.html#1704" class="Bound">b</a> <a id="1706" class="Symbol">:</a> <a id="1708" href="Overture.Inverses.html#654" class="Bound">B</a><a id="1709" class="Symbol">}(</a><a id="1711" href="Overture.Inverses.html#1711" class="Bound">q</a> <a id="1713" class="Symbol">:</a> <a id="1715" href="Overture.Inverses.html#677" class="Datatype Operator">Image</a> <a id="1721" href="Overture.Inverses.html#1693" class="Bound">f</a> <a id="1723" href="Overture.Inverses.html#677" class="Datatype Operator">∋</a> <a id="1725" href="Overture.Inverses.html#1704" class="Bound">b</a><a id="1726" class="Symbol">)</a> <a id="1728" class="Symbol">→</a> <a id="1730" href="Overture.Inverses.html#1693" class="Bound">f</a><a id="1731" class="Symbol">(</a><a id="1732" href="Overture.Inverses.html#1489" class="Function">Inv</a> <a id="1736" href="Overture.Inverses.html#1693" class="Bound">f</a> <a id="1738" href="Overture.Inverses.html#1711" class="Bound">q</a><a id="1739" class="Symbol">)</a> <a id="1741" href="Overture.Equality.html#2419" class="Datatype Operator">≡</a> <a id="1743" href="Overture.Inverses.html#1704" class="Bound">b</a>
 <a id="1746" href="Overture.Inverses.html#1681" class="Function">InvIsInv</a> <a id="1755" href="Overture.Inverses.html#1755" class="Bound">f</a> <a id="1757" class="Symbol">{</a><a id="1758" class="DottedPattern Symbol">.(</a><a id="1760" href="Overture.Inverses.html#1755" class="DottedPattern Bound">f</a> <a id="1762" href="Overture.Inverses.html#1770" class="DottedPattern Bound">a</a><a id="1763" class="DottedPattern Symbol">)</a><a id="1764" class="Symbol">}</a> <a id="1766" class="Symbol">(</a><a id="1767" href="Overture.Inverses.html#722" class="InductiveConstructor">im</a> <a id="1770" href="Overture.Inverses.html#1770" class="Bound">a</a><a id="1771" class="Symbol">)</a> <a id="1773" class="Symbol">=</a> <a id="1775" href="Identity-Type.html#162" class="InductiveConstructor">refl</a>
 <a id="1781" href="Overture.Inverses.html#1681" class="Function">InvIsInv</a> <a id="1790" href="Overture.Inverses.html#1790" class="Bound">f</a> <a id="1792" class="Symbol">(</a><a id="1793" href="Overture.Inverses.html#753" class="InductiveConstructor">eq</a> <a id="1796" class="Symbol">_</a> <a id="1798" class="Symbol">_</a> <a id="1800" href="Overture.Inverses.html#1800" class="Bound">p</a><a id="1801" class="Symbol">)</a> <a id="1803" class="Symbol">=</a> <a id="1805" href="Overture.Inverses.html#1800" class="Bound">p</a> <a id="1807" href="MGS-MLTT.html#6125" class="Function Operator">⁻¹</a>

</pre>





#### <a id="epics">Epics (surjective functions)</a>

An epic (or surjective) function from `A` to `B` is as an inhabitant of the `Epic` type, which we now define.

<pre class="Agda">

 <a id="2006" href="Overture.Inverses.html#2006" class="Function">Epic</a> <a id="2011" class="Symbol">:</a> <a id="2013" class="Symbol">(</a><a id="2014" href="Overture.Inverses.html#644" class="Bound">A</a> <a id="2016" class="Symbol">→</a> <a id="2018" href="Overture.Inverses.html#654" class="Bound">B</a><a id="2019" class="Symbol">)</a> <a id="2021" class="Symbol">→</a>  <a id="2024" href="Overture.Inverses.html#648" class="Bound">𝓤</a> <a id="2026" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a id="2028" href="Overture.Inverses.html#658" class="Bound">𝓦</a> <a id="2030" href="Universes.html#403" class="Function Operator">̇</a>
 <a id="2033" href="Overture.Inverses.html#2006" class="Function">Epic</a> <a id="2038" href="Overture.Inverses.html#2038" class="Bound">f</a> <a id="2040" class="Symbol">=</a> <a id="2042" class="Symbol">∀</a> <a id="2044" href="Overture.Inverses.html#2044" class="Bound">y</a> <a id="2046" class="Symbol">→</a> <a id="2048" href="Overture.Inverses.html#677" class="Datatype Operator">Image</a> <a id="2054" href="Overture.Inverses.html#2038" class="Bound">f</a> <a id="2056" href="Overture.Inverses.html#677" class="Datatype Operator">∋</a> <a id="2058" href="Overture.Inverses.html#2044" class="Bound">y</a>

</pre>

With the next definition, we can represent the *right-inverse* of an epic function.

<pre class="Agda">

 <a id="2173" href="Overture.Inverses.html#2173" class="Function">EpicInv</a> <a id="2181" class="Symbol">:</a> <a id="2183" class="Symbol">(</a><a id="2184" href="Overture.Inverses.html#2184" class="Bound">f</a> <a id="2186" class="Symbol">:</a> <a id="2188" href="Overture.Inverses.html#644" class="Bound">A</a> <a id="2190" class="Symbol">→</a> <a id="2192" href="Overture.Inverses.html#654" class="Bound">B</a><a id="2193" class="Symbol">)</a> <a id="2195" class="Symbol">→</a> <a id="2197" href="Overture.Inverses.html#2006" class="Function">Epic</a> <a id="2202" href="Overture.Inverses.html#2184" class="Bound">f</a> <a id="2204" class="Symbol">→</a> <a id="2206" href="Overture.Inverses.html#654" class="Bound">B</a> <a id="2208" class="Symbol">→</a> <a id="2210" href="Overture.Inverses.html#644" class="Bound">A</a>
 <a id="2213" href="Overture.Inverses.html#2173" class="Function">EpicInv</a> <a id="2221" href="Overture.Inverses.html#2221" class="Bound">f</a> <a id="2223" href="Overture.Inverses.html#2223" class="Bound">fE</a> <a id="2226" href="Overture.Inverses.html#2226" class="Bound">b</a> <a id="2228" class="Symbol">=</a> <a id="2230" href="Overture.Inverses.html#1489" class="Function">Inv</a> <a id="2234" href="Overture.Inverses.html#2221" class="Bound">f</a> <a id="2236" class="Symbol">(</a><a id="2237" href="Overture.Inverses.html#2223" class="Bound">fE</a> <a id="2240" href="Overture.Inverses.html#2226" class="Bound">b</a><a id="2241" class="Symbol">)</a>

</pre>
The right-inverse of `f` is obtained by applying `EpicInv` to `f` and a proof of `Epic f`. To see that this does indeed give the right-inverse we prove the `EpicInvIsRightInv` lemma below. This requires function composition, denoted `∘` and defined in the [Type Topology][] library.

<pre class="Agda">

<a id="2553" class="Keyword">module</a> <a id="hide-∘"></a><a id="2560" href="Overture.Inverses.html#2560" class="Module">hide-∘</a> <a id="2567" class="Symbol">{</a><a id="2568" href="Overture.Inverses.html#2568" class="Bound">A</a> <a id="2570" class="Symbol">:</a> <a id="2572" href="Universes.html#260" class="Generalizable">𝓤</a> <a id="2574" href="Universes.html#403" class="Function Operator">̇</a><a id="2575" class="Symbol">}{</a><a id="2577" href="Overture.Inverses.html#2577" class="Bound">B</a> <a id="2579" class="Symbol">:</a> <a id="2581" href="Universes.html#264" class="Generalizable">𝓦</a> <a id="2583" href="Universes.html#403" class="Function Operator">̇</a><a id="2584" class="Symbol">}{</a><a id="2586" href="Overture.Inverses.html#2586" class="Bound">C</a> <a id="2588" class="Symbol">:</a> <a id="2590" href="Overture.Inverses.html#2577" class="Bound">B</a> <a id="2592" class="Symbol">→</a> <a id="2594" href="Universes.html#264" class="Generalizable">𝓦</a> <a id="2596" href="Universes.html#403" class="Function Operator">̇</a> <a id="2598" class="Symbol">}</a> <a id="2600" class="Keyword">where</a>

 <a id="hide-∘._∘_"></a><a id="2608" href="Overture.Inverses.html#2608" class="Function Operator">_∘_</a> <a id="2612" class="Symbol">:</a> <a id="2614" href="MGS-MLTT.html#3562" class="Function">Π</a> <a id="2616" href="Overture.Inverses.html#2586" class="Bound">C</a> <a id="2618" class="Symbol">→</a> <a id="2620" class="Symbol">(</a><a id="2621" href="Overture.Inverses.html#2621" class="Bound">f</a> <a id="2623" class="Symbol">:</a> <a id="2625" href="Overture.Inverses.html#2568" class="Bound">A</a> <a id="2627" class="Symbol">→</a> <a id="2629" href="Overture.Inverses.html#2577" class="Bound">B</a><a id="2630" class="Symbol">)</a> <a id="2632" class="Symbol">→</a> <a id="2634" class="Symbol">(</a><a id="2635" href="Overture.Inverses.html#2635" class="Bound">x</a> <a id="2637" class="Symbol">:</a> <a id="2639" href="Overture.Inverses.html#2568" class="Bound">A</a><a id="2640" class="Symbol">)</a> <a id="2642" class="Symbol">→</a> <a id="2644" href="Overture.Inverses.html#2586" class="Bound">C</a> <a id="2646" class="Symbol">(</a><a id="2647" href="Overture.Inverses.html#2621" class="Bound">f</a> <a id="2649" href="Overture.Inverses.html#2635" class="Bound">x</a><a id="2650" class="Symbol">)</a>
 <a id="2653" href="Overture.Inverses.html#2653" class="Bound">g</a> <a id="2655" href="Overture.Inverses.html#2608" class="Function Operator">∘</a> <a id="2657" href="Overture.Inverses.html#2657" class="Bound">f</a> <a id="2659" class="Symbol">=</a> <a id="2661" class="Symbol">λ</a> <a id="2663" href="Overture.Inverses.html#2663" class="Bound">x</a> <a id="2665" class="Symbol">→</a> <a id="2667" href="Overture.Inverses.html#2653" class="Bound">g</a> <a id="2669" class="Symbol">(</a><a id="2670" href="Overture.Inverses.html#2657" class="Bound">f</a> <a id="2672" href="Overture.Inverses.html#2663" class="Bound">x</a><a id="2673" class="Symbol">)</a>

<a id="2676" class="Keyword">open</a> <a id="2681" class="Keyword">import</a> <a id="2688" href="MGS-MLTT.html" class="Module">MGS-MLTT</a> <a id="2697" class="Keyword">using</a> <a id="2703" class="Symbol">(</a><a id="2704" href="MGS-MLTT.html#3813" class="Function Operator">_∘_</a><a id="2707" class="Symbol">)</a> <a id="2709" class="Keyword">public</a>

</pre>

Note that the next proof requires function extensionality, which we postulate in the module declaration.

<pre class="Agda">

<a id="2849" class="Keyword">module</a> <a id="2856" href="Overture.Inverses.html#2856" class="Module">_</a> <a id="2858" class="Symbol">{</a><a id="2859" href="Overture.Inverses.html#2859" class="Bound">fe</a> <a id="2862" class="Symbol">:</a> <a id="2864" href="MGS-FunExt-from-Univalence.html#393" class="Function">funext</a> <a id="2871" href="Universes.html#264" class="Generalizable">𝓦</a> <a id="2873" href="Universes.html#264" class="Generalizable">𝓦</a><a id="2874" class="Symbol">}{</a><a id="2876" href="Overture.Inverses.html#2876" class="Bound">A</a> <a id="2878" class="Symbol">:</a> <a id="2880" href="Universes.html#260" class="Generalizable">𝓤</a> <a id="2882" href="Universes.html#403" class="Function Operator">̇</a><a id="2883" class="Symbol">}{</a><a id="2885" href="Overture.Inverses.html#2885" class="Bound">B</a> <a id="2887" class="Symbol">:</a> <a id="2889" href="Universes.html#264" class="Generalizable">𝓦</a> <a id="2891" href="Universes.html#403" class="Function Operator">̇</a><a id="2892" class="Symbol">}</a> <a id="2894" class="Keyword">where</a>

 <a id="2902" href="Overture.Inverses.html#2902" class="Function">EpicInvIsRightInv</a> <a id="2920" class="Symbol">:</a> <a id="2922" class="Symbol">(</a><a id="2923" href="Overture.Inverses.html#2923" class="Bound">f</a> <a id="2925" class="Symbol">:</a> <a id="2927" href="Overture.Inverses.html#2876" class="Bound">A</a> <a id="2929" class="Symbol">→</a> <a id="2931" href="Overture.Inverses.html#2885" class="Bound">B</a><a id="2932" class="Symbol">)(</a><a id="2934" href="Overture.Inverses.html#2934" class="Bound">fE</a> <a id="2937" class="Symbol">:</a> <a id="2939" href="Overture.Inverses.html#2006" class="Function">Epic</a> <a id="2944" href="Overture.Inverses.html#2923" class="Bound">f</a><a id="2945" class="Symbol">)</a> <a id="2947" class="Symbol">→</a> <a id="2949" href="Overture.Inverses.html#2923" class="Bound">f</a> <a id="2951" href="MGS-MLTT.html#3813" class="Function Operator">∘</a> <a id="2953" class="Symbol">(</a><a id="2954" href="Overture.Inverses.html#2173" class="Function">EpicInv</a> <a id="2962" href="Overture.Inverses.html#2923" class="Bound">f</a> <a id="2964" href="Overture.Inverses.html#2934" class="Bound">fE</a><a id="2966" class="Symbol">)</a> <a id="2968" href="Overture.Equality.html#2419" class="Datatype Operator">≡</a> <a id="2970" href="MGS-MLTT.html#3778" class="Function">𝑖𝑑</a> <a id="2973" href="Overture.Inverses.html#2885" class="Bound">B</a>
 <a id="2976" href="Overture.Inverses.html#2902" class="Function">EpicInvIsRightInv</a> <a id="2994" href="Overture.Inverses.html#2994" class="Bound">f</a> <a id="2996" href="Overture.Inverses.html#2996" class="Bound">fE</a> <a id="2999" class="Symbol">=</a> <a id="3001" href="Overture.Inverses.html#2859" class="Bound">fe</a> <a id="3004" class="Symbol">(λ</a> <a id="3007" href="Overture.Inverses.html#3007" class="Bound">x</a> <a id="3009" class="Symbol">→</a> <a id="3011" href="Overture.Inverses.html#1681" class="Function">InvIsInv</a> <a id="3020" href="Overture.Inverses.html#2994" class="Bound">f</a> <a id="3022" class="Symbol">(</a><a id="3023" href="Overture.Inverses.html#2996" class="Bound">fE</a> <a id="3026" href="Overture.Inverses.html#3007" class="Bound">x</a><a id="3027" class="Symbol">))</a>

</pre>

We can also prove the following composition law for epics.

<pre class="Agda">

 <a id="3118" href="Overture.Inverses.html#3118" class="Function">epic-factor</a> <a id="3130" class="Symbol">:</a> <a id="3132" class="Symbol">{</a><a id="3133" href="Overture.Inverses.html#3133" class="Bound">C</a> <a id="3135" class="Symbol">:</a> <a id="3137" href="Overture.Preliminaries.html#8163" class="Generalizable">𝓩</a> <a id="3139" href="Universes.html#403" class="Function Operator">̇</a><a id="3140" class="Symbol">}(</a><a id="3142" href="Overture.Inverses.html#3142" class="Bound">f</a> <a id="3144" class="Symbol">:</a> <a id="3146" href="Overture.Inverses.html#2876" class="Bound">A</a> <a id="3148" class="Symbol">→</a> <a id="3150" href="Overture.Inverses.html#2885" class="Bound">B</a><a id="3151" class="Symbol">)(</a><a id="3153" href="Overture.Inverses.html#3153" class="Bound">g</a> <a id="3155" class="Symbol">:</a> <a id="3157" href="Overture.Inverses.html#2876" class="Bound">A</a> <a id="3159" class="Symbol">→</a> <a id="3161" href="Overture.Inverses.html#3133" class="Bound">C</a><a id="3162" class="Symbol">)(</a><a id="3164" href="Overture.Inverses.html#3164" class="Bound">h</a> <a id="3166" class="Symbol">:</a> <a id="3168" href="Overture.Inverses.html#3133" class="Bound">C</a> <a id="3170" class="Symbol">→</a> <a id="3172" href="Overture.Inverses.html#2885" class="Bound">B</a><a id="3173" class="Symbol">)</a>
  <a id="3177" class="Symbol">→</a>            <a id="3190" href="Overture.Inverses.html#3142" class="Bound">f</a> <a id="3192" href="Overture.Equality.html#2419" class="Datatype Operator">≡</a> <a id="3194" href="Overture.Inverses.html#3164" class="Bound">h</a> <a id="3196" href="MGS-MLTT.html#3813" class="Function Operator">∘</a> <a id="3198" href="Overture.Inverses.html#3153" class="Bound">g</a> <a id="3200" class="Symbol">→</a> <a id="3202" href="Overture.Inverses.html#2006" class="Function">Epic</a> <a id="3207" href="Overture.Inverses.html#3142" class="Bound">f</a> <a id="3209" class="Symbol">→</a> <a id="3211" href="Overture.Inverses.html#2006" class="Function">Epic</a> <a id="3216" href="Overture.Inverses.html#3164" class="Bound">h</a>

 <a id="3220" href="Overture.Inverses.html#3118" class="Function">epic-factor</a> <a id="3232" href="Overture.Inverses.html#3232" class="Bound">f</a> <a id="3234" href="Overture.Inverses.html#3234" class="Bound">g</a> <a id="3236" href="Overture.Inverses.html#3236" class="Bound">h</a> <a id="3238" href="Overture.Inverses.html#3238" class="Bound">compId</a> <a id="3245" href="Overture.Inverses.html#3245" class="Bound">fe</a> <a id="3248" href="Overture.Inverses.html#3248" class="Bound">y</a> <a id="3250" class="Symbol">=</a> <a id="3252" href="Overture.Inverses.html#3442" class="Function">γ</a>
  <a id="3256" class="Keyword">where</a>
   <a id="3265" href="Overture.Inverses.html#3265" class="Function">finv</a> <a id="3270" class="Symbol">:</a> <a id="3272" href="Overture.Inverses.html#2885" class="Bound">B</a> <a id="3274" class="Symbol">→</a> <a id="3276" href="Overture.Inverses.html#2876" class="Bound">A</a>
   <a id="3281" href="Overture.Inverses.html#3265" class="Function">finv</a> <a id="3286" class="Symbol">=</a> <a id="3288" href="Overture.Inverses.html#2173" class="Function">EpicInv</a> <a id="3296" href="Overture.Inverses.html#3232" class="Bound">f</a> <a id="3298" href="Overture.Inverses.html#3245" class="Bound">fe</a>

   <a id="3305" href="Overture.Inverses.html#3305" class="Function">ζ</a> <a id="3307" class="Symbol">:</a> <a id="3309" href="Overture.Inverses.html#3232" class="Bound">f</a> <a id="3311" class="Symbol">(</a><a id="3312" href="Overture.Inverses.html#3265" class="Function">finv</a> <a id="3317" href="Overture.Inverses.html#3248" class="Bound">y</a><a id="3318" class="Symbol">)</a> <a id="3320" href="Overture.Equality.html#2419" class="Datatype Operator">≡</a> <a id="3322" href="Overture.Inverses.html#3248" class="Bound">y</a>
   <a id="3327" href="Overture.Inverses.html#3305" class="Function">ζ</a> <a id="3329" class="Symbol">=</a> <a id="3331" href="Overture.Equality.html#5962" class="Function">cong-app</a> <a id="3340" class="Symbol">(</a><a id="3341" href="Overture.Inverses.html#2902" class="Function">EpicInvIsRightInv</a> <a id="3359" href="Overture.Inverses.html#3232" class="Bound">f</a> <a id="3361" href="Overture.Inverses.html#3245" class="Bound">fe</a><a id="3363" class="Symbol">)</a> <a id="3365" href="Overture.Inverses.html#3248" class="Bound">y</a>

   <a id="3371" href="Overture.Inverses.html#3371" class="Function">η</a> <a id="3373" class="Symbol">:</a> <a id="3375" class="Symbol">(</a><a id="3376" href="Overture.Inverses.html#3236" class="Bound">h</a> <a id="3378" href="MGS-MLTT.html#3813" class="Function Operator">∘</a> <a id="3380" href="Overture.Inverses.html#3234" class="Bound">g</a><a id="3381" class="Symbol">)</a> <a id="3383" class="Symbol">(</a><a id="3384" href="Overture.Inverses.html#3265" class="Function">finv</a> <a id="3389" href="Overture.Inverses.html#3248" class="Bound">y</a><a id="3390" class="Symbol">)</a> <a id="3392" href="Overture.Equality.html#2419" class="Datatype Operator">≡</a> <a id="3394" href="Overture.Inverses.html#3248" class="Bound">y</a>
   <a id="3399" href="Overture.Inverses.html#3371" class="Function">η</a> <a id="3401" class="Symbol">=</a> <a id="3403" class="Symbol">(</a><a id="3404" href="Overture.Equality.html#5962" class="Function">cong-app</a> <a id="3413" class="Symbol">(</a><a id="3414" href="Overture.Inverses.html#3238" class="Bound">compId</a> <a id="3421" href="MGS-MLTT.html#6125" class="Function Operator">⁻¹</a><a id="3423" class="Symbol">)(</a><a id="3425" href="Overture.Inverses.html#3265" class="Function">finv</a> <a id="3430" href="Overture.Inverses.html#3248" class="Bound">y</a><a id="3431" class="Symbol">))</a> <a id="3434" href="MGS-MLTT.html#5910" class="Function Operator">∙</a> <a id="3436" href="Overture.Inverses.html#3305" class="Function">ζ</a>

   <a id="3442" href="Overture.Inverses.html#3442" class="Function">γ</a> <a id="3444" class="Symbol">:</a> <a id="3446" href="Overture.Inverses.html#677" class="Datatype Operator">Image</a> <a id="3452" href="Overture.Inverses.html#3236" class="Bound">h</a> <a id="3454" href="Overture.Inverses.html#677" class="Datatype Operator">∋</a> <a id="3456" href="Overture.Inverses.html#3248" class="Bound">y</a>
   <a id="3461" href="Overture.Inverses.html#3442" class="Function">γ</a> <a id="3463" class="Symbol">=</a> <a id="3465" href="Overture.Inverses.html#753" class="InductiveConstructor">eq</a> <a id="3468" href="Overture.Inverses.html#3248" class="Bound">y</a> <a id="3470" class="Symbol">(</a><a id="3471" href="Overture.Inverses.html#3234" class="Bound">g</a> <a id="3473" class="Symbol">(</a><a id="3474" href="Overture.Inverses.html#3265" class="Function">finv</a> <a id="3479" href="Overture.Inverses.html#3248" class="Bound">y</a><a id="3480" class="Symbol">))</a> <a id="3483" class="Symbol">(</a><a id="3484" href="Overture.Inverses.html#3371" class="Function">η</a> <a id="3486" href="MGS-MLTT.html#6125" class="Function Operator">⁻¹</a><a id="3488" class="Symbol">)</a>

</pre>






#### <a id="monics">Monics (injective functions)</a>

We say that a function `f : A → B` is *monic* (or *injective*) if it does not map distinct elements to a common point. This following type manifests this property.

<pre class="Agda">

<a id="3741" class="Keyword">module</a> <a id="3748" href="Overture.Inverses.html#3748" class="Module">_</a> <a id="3750" class="Symbol">{</a><a id="3751" href="Overture.Inverses.html#3751" class="Bound">A</a> <a id="3753" class="Symbol">:</a> <a id="3755" href="Universes.html#260" class="Generalizable">𝓤</a> <a id="3757" href="Universes.html#403" class="Function Operator">̇</a><a id="3758" class="Symbol">}{</a><a id="3760" href="Overture.Inverses.html#3760" class="Bound">B</a> <a id="3762" class="Symbol">:</a> <a id="3764" href="Universes.html#264" class="Generalizable">𝓦</a> <a id="3766" href="Universes.html#403" class="Function Operator">̇</a><a id="3767" class="Symbol">}</a> <a id="3769" class="Keyword">where</a>

 <a id="3777" href="Overture.Inverses.html#3777" class="Function">Monic</a> <a id="3783" class="Symbol">:</a> <a id="3785" class="Symbol">(</a><a id="3786" href="Overture.Inverses.html#3786" class="Bound">f</a> <a id="3788" class="Symbol">:</a> <a id="3790" href="Overture.Inverses.html#3751" class="Bound">A</a> <a id="3792" class="Symbol">→</a> <a id="3794" href="Overture.Inverses.html#3760" class="Bound">B</a><a id="3795" class="Symbol">)</a> <a id="3797" class="Symbol">→</a> <a id="3799" href="Overture.Inverses.html#3755" class="Bound">𝓤</a> <a id="3801" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a id="3803" href="Overture.Inverses.html#3764" class="Bound">𝓦</a> <a id="3805" href="Universes.html#403" class="Function Operator">̇</a>
 <a id="3808" href="Overture.Inverses.html#3777" class="Function">Monic</a> <a id="3814" href="Overture.Inverses.html#3814" class="Bound">f</a> <a id="3816" class="Symbol">=</a> <a id="3818" class="Symbol">∀</a> <a id="3820" href="Overture.Inverses.html#3820" class="Bound">x</a> <a id="3822" href="Overture.Inverses.html#3822" class="Bound">y</a> <a id="3824" class="Symbol">→</a> <a id="3826" href="Overture.Inverses.html#3814" class="Bound">f</a> <a id="3828" href="Overture.Inverses.html#3820" class="Bound">x</a> <a id="3830" href="Overture.Equality.html#2419" class="Datatype Operator">≡</a> <a id="3832" href="Overture.Inverses.html#3814" class="Bound">f</a> <a id="3834" href="Overture.Inverses.html#3822" class="Bound">y</a> <a id="3836" class="Symbol">→</a> <a id="3838" href="Overture.Inverses.html#3820" class="Bound">x</a> <a id="3840" href="Overture.Equality.html#2419" class="Datatype Operator">≡</a> <a id="3842" href="Overture.Inverses.html#3822" class="Bound">y</a>

</pre>

Again, we obtain a pseudoinverse. Here it is obtained by applying the function `MonicInv` to `g` and a proof that `g` is monic.

<pre class="Agda">

 <a id="4001" href="Overture.Inverses.html#4001" class="Function">MonicInv</a> <a id="4010" class="Symbol">:</a> <a id="4012" class="Symbol">(</a><a id="4013" href="Overture.Inverses.html#4013" class="Bound">f</a> <a id="4015" class="Symbol">:</a> <a id="4017" href="Overture.Inverses.html#3751" class="Bound">A</a> <a id="4019" class="Symbol">→</a> <a id="4021" href="Overture.Inverses.html#3760" class="Bound">B</a><a id="4022" class="Symbol">)</a> <a id="4024" class="Symbol">→</a> <a id="4026" href="Overture.Inverses.html#3777" class="Function">Monic</a> <a id="4032" href="Overture.Inverses.html#4013" class="Bound">f</a> <a id="4034" class="Symbol">→</a> <a id="4036" class="Symbol">(</a><a id="4037" href="Overture.Inverses.html#4037" class="Bound">b</a> <a id="4039" class="Symbol">:</a> <a id="4041" href="Overture.Inverses.html#3760" class="Bound">B</a><a id="4042" class="Symbol">)</a> <a id="4044" class="Symbol">→</a> <a id="4046" href="Overture.Inverses.html#677" class="Datatype Operator">Image</a> <a id="4052" href="Overture.Inverses.html#4013" class="Bound">f</a> <a id="4054" href="Overture.Inverses.html#677" class="Datatype Operator">∋</a> <a id="4056" href="Overture.Inverses.html#4037" class="Bound">b</a> <a id="4058" class="Symbol">→</a> <a id="4060" href="Overture.Inverses.html#3751" class="Bound">A</a>
 <a id="4063" href="Overture.Inverses.html#4001" class="Function">MonicInv</a> <a id="4072" href="Overture.Inverses.html#4072" class="Bound">f</a> <a id="4074" class="Symbol">_</a> <a id="4076" class="Symbol">=</a> <a id="4078" class="Symbol">λ</a> <a id="4080" href="Overture.Inverses.html#4080" class="Bound">b</a> <a id="4082" href="Overture.Inverses.html#4082" class="Bound">imfb</a> <a id="4087" class="Symbol">→</a> <a id="4089" href="Overture.Inverses.html#1489" class="Function">Inv</a> <a id="4093" href="Overture.Inverses.html#4072" class="Bound">f</a> <a id="4095" href="Overture.Inverses.html#4082" class="Bound">imfb</a>

</pre>

The function defined by `MonicInv f fM` is the left-inverse of `f`.

<pre class="Agda">

 <a id="4197" href="Overture.Inverses.html#4197" class="Function">MonicInvIsLeftInv</a> <a id="4215" class="Symbol">:</a> <a id="4217" class="Symbol">{</a><a id="4218" href="Overture.Inverses.html#4218" class="Bound">f</a> <a id="4220" class="Symbol">:</a> <a id="4222" href="Overture.Inverses.html#3751" class="Bound">A</a> <a id="4224" class="Symbol">→</a> <a id="4226" href="Overture.Inverses.html#3760" class="Bound">B</a><a id="4227" class="Symbol">}{</a><a id="4229" href="Overture.Inverses.html#4229" class="Bound">fM</a> <a id="4232" class="Symbol">:</a> <a id="4234" href="Overture.Inverses.html#3777" class="Function">Monic</a> <a id="4240" href="Overture.Inverses.html#4218" class="Bound">f</a><a id="4241" class="Symbol">}{</a><a id="4243" href="Overture.Inverses.html#4243" class="Bound">x</a> <a id="4245" class="Symbol">:</a> <a id="4247" href="Overture.Inverses.html#3751" class="Bound">A</a><a id="4248" class="Symbol">}</a> <a id="4250" class="Symbol">→</a> <a id="4252" class="Symbol">(</a><a id="4253" href="Overture.Inverses.html#4001" class="Function">MonicInv</a> <a id="4262" href="Overture.Inverses.html#4218" class="Bound">f</a> <a id="4264" href="Overture.Inverses.html#4229" class="Bound">fM</a><a id="4266" class="Symbol">)(</a><a id="4268" href="Overture.Inverses.html#4218" class="Bound">f</a> <a id="4270" href="Overture.Inverses.html#4243" class="Bound">x</a><a id="4271" class="Symbol">)(</a><a id="4273" href="Overture.Inverses.html#722" class="InductiveConstructor">im</a> <a id="4276" href="Overture.Inverses.html#4243" class="Bound">x</a><a id="4277" class="Symbol">)</a> <a id="4279" href="Overture.Equality.html#2419" class="Datatype Operator">≡</a> <a id="4281" href="Overture.Inverses.html#4243" class="Bound">x</a>
 <a id="4284" href="Overture.Inverses.html#4197" class="Function">MonicInvIsLeftInv</a> <a id="4302" class="Symbol">=</a> <a id="4304" href="Identity-Type.html#162" class="InductiveConstructor">refl</a>

</pre>





#### <a id="embeddings">Embeddings</a>

The `is-embedding` type is defined in the [Type Topology][] library in the following way.

<pre class="Agda">
<a id="4470" class="Keyword">module</a> <a id="hide-is-embedding"></a><a id="4477" href="Overture.Inverses.html#4477" class="Module">hide-is-embedding</a><a id="4494" class="Symbol">{</a><a id="4495" href="Overture.Inverses.html#4495" class="Bound">A</a> <a id="4497" class="Symbol">:</a> <a id="4499" href="Universes.html#260" class="Generalizable">𝓤</a> <a id="4501" href="Universes.html#403" class="Function Operator">̇</a><a id="4502" class="Symbol">}{</a><a id="4504" href="Overture.Inverses.html#4504" class="Bound">B</a> <a id="4506" class="Symbol">:</a> <a id="4508" href="Universes.html#264" class="Generalizable">𝓦</a> <a id="4510" href="Universes.html#403" class="Function Operator">̇</a><a id="4511" class="Symbol">}</a> <a id="4513" class="Keyword">where</a>

 <a id="hide-is-embedding.is-embedding"></a><a id="4521" href="Overture.Inverses.html#4521" class="Function">is-embedding</a> <a id="4534" class="Symbol">:</a> <a id="4536" class="Symbol">(</a><a id="4537" href="Overture.Inverses.html#4495" class="Bound">A</a> <a id="4539" class="Symbol">→</a> <a id="4541" href="Overture.Inverses.html#4504" class="Bound">B</a><a id="4542" class="Symbol">)</a> <a id="4544" class="Symbol">→</a> <a id="4546" href="Overture.Inverses.html#4499" class="Bound">𝓤</a> <a id="4548" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a id="4550" href="Overture.Inverses.html#4508" class="Bound">𝓦</a> <a id="4552" href="Universes.html#403" class="Function Operator">̇</a>
 <a id="4555" href="Overture.Inverses.html#4521" class="Function">is-embedding</a> <a id="4568" href="Overture.Inverses.html#4568" class="Bound">f</a> <a id="4570" class="Symbol">=</a> <a id="4572" class="Symbol">∀</a> <a id="4574" href="Overture.Inverses.html#4574" class="Bound">b</a> <a id="4576" class="Symbol">→</a> <a id="4578" href="MGS-Basic-UF.html#743" class="Function">is-subsingleton</a> <a id="4594" class="Symbol">(</a><a id="4595" href="MGS-Equivalences.html#501" class="Function">fiber</a> <a id="4601" href="Overture.Inverses.html#4568" class="Bound">f</a> <a id="4603" href="Overture.Inverses.html#4574" class="Bound">b</a><a id="4604" class="Symbol">)</a>

<a id="4607" class="Keyword">open</a> <a id="4612" class="Keyword">import</a> <a id="4619" href="MGS-Embeddings.html" class="Module">MGS-Embeddings</a> <a id="4634" class="Keyword">using</a> <a id="4640" class="Symbol">(</a><a id="4641" href="MGS-Embeddings.html#384" class="Function">is-embedding</a><a id="4653" class="Symbol">)</a> <a id="4655" class="Keyword">public</a>

</pre>

Thus, `is-embedding f` asserts that `f` is a function all of whose fibers are subsingletons. Observe that an embedding is not simply an injective map. However, if we assume that the codomain `B` has *unique identity proofs* (UIP), then we can prove that a monic function into `B` is an embedding.  We will do exactly that in the [Relations.Truncation][] module when we take up the topic of *sets* and the UIP.

Finding a proof that a function is an embedding isn't always easy, but one path that is often straightforward is to first prove that the function is invertible and then invoke the following theorem.

<pre class="Agda">

<a id="5300" class="Keyword">module</a> <a id="5307" href="Overture.Inverses.html#5307" class="Module">_</a> <a id="5309" class="Symbol">{</a><a id="5310" href="Overture.Inverses.html#5310" class="Bound">A</a> <a id="5312" class="Symbol">:</a> <a id="5314" href="Universes.html#260" class="Generalizable">𝓤</a> <a id="5316" href="Universes.html#403" class="Function Operator">̇</a><a id="5317" class="Symbol">}{</a><a id="5319" href="Overture.Inverses.html#5319" class="Bound">B</a> <a id="5321" class="Symbol">:</a> <a id="5323" href="Universes.html#264" class="Generalizable">𝓦</a> <a id="5325" href="Universes.html#403" class="Function Operator">̇</a><a id="5326" class="Symbol">}</a> <a id="5328" class="Keyword">where</a>

 <a id="5336" href="Overture.Inverses.html#5336" class="Function">invertibles-are-embeddings</a> <a id="5363" class="Symbol">:</a> <a id="5365" class="Symbol">(</a><a id="5366" href="Overture.Inverses.html#5366" class="Bound">f</a> <a id="5368" class="Symbol">:</a> <a id="5370" href="Overture.Inverses.html#5310" class="Bound">A</a> <a id="5372" class="Symbol">→</a> <a id="5374" href="Overture.Inverses.html#5319" class="Bound">B</a><a id="5375" class="Symbol">)</a> <a id="5377" class="Symbol">→</a> <a id="5379" href="MGS-Equivalences.html#370" class="Function">invertible</a> <a id="5390" href="Overture.Inverses.html#5366" class="Bound">f</a> <a id="5392" class="Symbol">→</a> <a id="5394" href="MGS-Embeddings.html#384" class="Function">is-embedding</a> <a id="5407" href="Overture.Inverses.html#5366" class="Bound">f</a>
 <a id="5410" href="Overture.Inverses.html#5336" class="Function">invertibles-are-embeddings</a> <a id="5437" href="Overture.Inverses.html#5437" class="Bound">f</a> <a id="5439" href="Overture.Inverses.html#5439" class="Bound">fi</a> <a id="5442" class="Symbol">=</a> <a id="5444" href="MGS-Embeddings.html#1410" class="Function">equivs-are-embeddings</a> <a id="5466" href="Overture.Inverses.html#5437" class="Bound">f</a> <a id="5468" class="Symbol">(</a><a id="5469" href="MGS-Equivalences.html#2127" class="Function">invertibles-are-equivs</a> <a id="5492" href="Overture.Inverses.html#5437" class="Bound">f</a> <a id="5494" href="Overture.Inverses.html#5439" class="Bound">fi</a><a id="5496" class="Symbol">)</a>

</pre>

Finally, embeddings are monic; from a proof `p : is-embedding f` that `f` is an embedding we can construct a proof of `Monic f`.  We confirm this as follows.

<pre class="Agda">

 <a id="5685" href="Overture.Inverses.html#5685" class="Function">embedding-is-monic</a> <a id="5704" class="Symbol">:</a> <a id="5706" class="Symbol">(</a><a id="5707" href="Overture.Inverses.html#5707" class="Bound">f</a> <a id="5709" class="Symbol">:</a> <a id="5711" href="Overture.Inverses.html#5310" class="Bound">A</a> <a id="5713" class="Symbol">→</a> <a id="5715" href="Overture.Inverses.html#5319" class="Bound">B</a><a id="5716" class="Symbol">)</a> <a id="5718" class="Symbol">→</a> <a id="5720" href="MGS-Embeddings.html#384" class="Function">is-embedding</a> <a id="5733" href="Overture.Inverses.html#5707" class="Bound">f</a> <a id="5735" class="Symbol">→</a> <a id="5737" href="Overture.Inverses.html#3777" class="Function">Monic</a> <a id="5743" href="Overture.Inverses.html#5707" class="Bound">f</a>
 <a id="5746" href="Overture.Inverses.html#5685" class="Function">embedding-is-monic</a> <a id="5765" href="Overture.Inverses.html#5765" class="Bound">f</a> <a id="5767" href="Overture.Inverses.html#5767" class="Bound">femb</a> <a id="5772" href="Overture.Inverses.html#5772" class="Bound">x</a> <a id="5774" href="Overture.Inverses.html#5774" class="Bound">y</a> <a id="5776" href="Overture.Inverses.html#5776" class="Bound">fxfy</a> <a id="5781" class="Symbol">=</a> <a id="5783" href="MGS-MLTT.html#6613" class="Function">ap</a> <a id="5786" href="MGS-MLTT.html#2942" class="Function">pr₁</a> <a id="5790" class="Symbol">((</a><a id="5792" href="Overture.Inverses.html#5767" class="Bound">femb</a> <a id="5797" class="Symbol">(</a><a id="5798" href="Overture.Inverses.html#5765" class="Bound">f</a> <a id="5800" href="Overture.Inverses.html#5772" class="Bound">x</a><a id="5801" class="Symbol">))</a> <a id="5804" href="Overture.Inverses.html#5821" class="Function">fx</a> <a id="5807" href="Overture.Inverses.html#5824" class="Function">fy</a><a id="5809" class="Symbol">)</a>
  <a id="5813" class="Keyword">where</a>
  <a id="5821" href="Overture.Inverses.html#5821" class="Function">fx</a> <a id="5824" href="Overture.Inverses.html#5824" class="Function">fy</a> <a id="5827" class="Symbol">:</a> <a id="5829" href="MGS-Equivalences.html#501" class="Function">fiber</a> <a id="5835" href="Overture.Inverses.html#5765" class="Bound">f</a> <a id="5837" class="Symbol">(</a><a id="5838" href="Overture.Inverses.html#5765" class="Bound">f</a> <a id="5840" href="Overture.Inverses.html#5772" class="Bound">x</a><a id="5841" class="Symbol">)</a>
  <a id="5845" href="Overture.Inverses.html#5821" class="Function">fx</a> <a id="5848" class="Symbol">=</a> <a id="5850" href="Overture.Inverses.html#5772" class="Bound">x</a> <a id="5852" href="Overture.Preliminaries.html#13136" class="InductiveConstructor Operator">,</a> <a id="5854" href="Identity-Type.html#162" class="InductiveConstructor">refl</a>
  <a id="5861" href="Overture.Inverses.html#5824" class="Function">fy</a> <a id="5864" class="Symbol">=</a> <a id="5866" href="Overture.Inverses.html#5774" class="Bound">y</a> <a id="5868" href="Overture.Preliminaries.html#13136" class="InductiveConstructor Operator">,</a> <a id="5870" class="Symbol">(</a><a id="5871" href="Overture.Inverses.html#5776" class="Bound">fxfy</a> <a id="5876" href="MGS-MLTT.html#6125" class="Function Operator">⁻¹</a><a id="5878" class="Symbol">)</a>

</pre>


-------------------------------------

<p></p>

[← Overture.FunExtensionality](Overture.FunExtensionality.html)
<span style="float:right;">[Overture.Lifts →](Overture.Lifts.html)</span>


{% include UALib.Links.md %}


<!-- 
This is the first point at which [truncation](UALib.Preface.html#truncation) comes into play.  An [embedding](https://www.cs.bham.ac.uk/~mhe/HoTT-UF-in-Agda-Lecture-Notes/HoTT-UF-Agda.html#embeddings) is defined in the [Type Topology][] library, using the `is-subsingleton` type [described earlier](Overture.Extensionality.html#alternative-extensionality-type), as follows.
-->
